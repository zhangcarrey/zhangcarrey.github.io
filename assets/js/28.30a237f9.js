(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{572:function(e,t,r){"use strict";r.r(t);var o=r(12),l=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"mvc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[e._v("#")]),e._v(" MVC")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://lc-gold-cdn.xitu.io/9da7ababda36b88a5dd7.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"MVC"}})]),e._v(" "),r("blockquote",[r("p",[e._v("MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。")])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("Model层用来存储业务的数据，一旦数据发生变化，模型将通知有关的视图。")])]),e._v(" "),r("li",[r("p",[e._v("view和controller之间使用了策略模式")])]),e._v(" "),r("li",[r("p",[e._v("controller, 控制器是模型和视图之间的纽带，MVC将响应机制封装在controller对象中，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了")])])]),e._v(" "),r("p",[e._v("传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。")]),e._v(" "),r("p",[e._v("可以明显感觉到，MVC模式的业务逻辑主要集中在Controller，而前端的View其实已经具备了独立处理用户事件的能力，当每个事件都流经Controller时，这层会变得十分臃肿。而且MVC中View和Controller一般是一一对应的，捆绑起来表示一个组件，视图与控制器间的过于紧密的连接让Controller的复用性成了问题，如果想多个View共用一个Controller该怎么办呢？这里有一个解决方案：")]),e._v(" "),r("h3",{attrs:{id:"mvp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvp"}},[e._v("#")]),e._v(" MVP")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://lc-gold-cdn.xitu.io/7e6efa438bda9cb0073d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"MVP"}})]),e._v(" "),r("p",[e._v("Presenter作为View和Model之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从View到Model和从Model到View的数据进行“手动同步”，这样Presenter显得很重，维护起来会比较困难。而且由于没有数据绑定，如果Presenter对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，Presenter也需要改动。")]),e._v(" "),r("h3",{attrs:{id:"mvvm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/15226743-1b2adc4a66e12c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/715/format/webp",alt:"MVVM"}})]),e._v(" "),r("ul",[r("li",[e._v("以持有关系来说view持有viewmodel，viewmodel持有model。view向viewmodel传递事件，viewmodel将事件过滤加工并根据需要更新model。model变化后被viewmodel观察到（通过绑定），并将model更新后的数据根据业务逻辑映射为展示用的数据，最后view观察到viewmodel的变化并根据最新的展示数据刷新自身。这里view只认识viewmodel，viewmodel只认识model，model谁也不认识。")]),e._v(" "),r("li",[e._v("由于使用MVP会使Presenter中的代码逻辑变得臃肿，所有用ViewModel代替。ViewModel和View之间不是通信的关系而是绑定的关系。这意味着当你更新viewmodel层的数据的时候，view层会相应的变动ui。")])]),e._v(" "),r("h4",{attrs:{id:"链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[e._v("#")]),e._v(" 链接")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/593021272f301e0058273468",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅析前端开发中的 MVC/MVP/MVVM 模式"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=l.exports}}]);