(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{570:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"原始-primitive-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原始-primitive-类型"}},[t._v("#")]),t._v(" 原始(Primitive)类型")]),t._v(" "),a("p",[t._v("在 JS 中，存在着 6 种原始值，分别是：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("boolean")])]),t._v(" "),a("li",[a("code",[t._v("null")])]),t._v(" "),a("li",[a("code",[t._v("undefined")])]),t._v(" "),a("li",[a("code",[t._v("number")])]),t._v(" "),a("li",[a("code",[t._v("string")])]),t._v(" "),a("li",[a("code",[t._v("symbol")])])]),t._v(" "),a("ol",[a("li",[t._v("原始类型存储的都是值，是没有函数可以调用的。此时你肯定会有疑问，这不对呀，明明 "),a("code",[t._v("'1'.toString()")]),t._v(" 是可以使用的。其实在这种情况下，"),a("code",[t._v("'1'")]),t._v(" 已经不是原始类型了，而是被强制转换成了 "),a("code",[t._v("String")]),t._v(" 类型也就是对象类型，所以可以调用 "),a("code",[t._v("toString")]),t._v(" 函数。")]),t._v(" "),a("li",[a("code",[t._v("string")]),t._v(" 类型是不可变的，无论你在 "),a("code",[t._v("string")]),t._v(" 类型上调用何种方法，都不会对值有改变。")])]),t._v(" "),a("h3",{attrs:{id:"对象-object-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象-object-类型"}},[t._v("#")]),t._v(" 对象(Object)类型")]),t._v(" "),a("p",[t._v("在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，==原始类型存储的是值，对象类型存储的是地址（指针）==。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。")]),t._v(" "),a("h3",{attrs:{id:"类型转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[t._v("#")]),t._v(" 类型转换")]),t._v(" "),a("p",[t._v("首先我们要知道，在 JS 中类型转换只有三种情况，分别是：")]),t._v(" "),a("ul",[a("li",[t._v("转换为布尔值")]),t._v(" "),a("li",[t._v("转换为数字")]),t._v(" "),a("li",[t._v("转换为字符串")])]),t._v(" "),a("p",[a("em",[t._v("注意图中有一个错误，Boolean 转字符串这行结果我指的是 true 转字符串的例子，不是说 Boolean、函数、Symblo 转字符串都是")]),t._v(" "),a("code",[t._v("true")]),t._v(" "),a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"类型转换表格"}})]),t._v(" "),a("h5",{attrs:{id:"转boolean"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转boolean"}},[t._v("#")]),t._v(" 转Boolean")]),t._v(" "),a("p",[t._v("在条件判断时，除了 "),a("code",[t._v("undefined， null， false， NaN， ''， 0， -0")]),t._v("，其他所有值都转为 "),a("code",[t._v("true")]),t._v("，包括所有对象。")]),t._v(" "),a("h5",{attrs:{id:"对象转原始类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象转原始类型"}},[t._v("#")]),t._v(" 对象转原始类型")]),t._v(" "),a("p",[t._v("对象在转换类型的时候，会调用内置的 "),a("code",[t._v("[[ToPrimitive]]")]),t._v(" 函数，对于该函数来说，算法逻辑一般来说如下：")]),t._v(" "),a("ul",[a("li",[t._v("如果已经是原始类型了，那就不需要转换了")]),t._v(" "),a("li",[t._v("如果需要转字符串类型就调用 "),a("code",[t._v("x.toString()")]),t._v("，转换的结果为基础类型的话就返回转换的值。不是字符串类型的话就先调用 "),a("code",[t._v("valueOf")]),t._v("，结果不是基础类型的话再调用 "),a("code",[t._v("toString")])]),t._v(" "),a("li",[t._v("调用 "),a("code",[t._v("x.valueOf()")]),t._v("，如果转换为基础类型，就返回转换的值")]),t._v(" "),a("li",[t._v("如果都没有返回原始类型，就会报错")])]),t._v(" "),a("p",[t._v("当然你也可以重写 "),a("code",[t._v("Symbol.toPrimitive")]),t._v(" ，该方法在转原始类型时调用优先级最高。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("toPrimitive"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// => 3")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("h5",{attrs:{id:"四则运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四则运算符"}},[t._v("#")]),t._v(" 四则运算符")]),t._v(" "),a("p",[t._v("加法运算符不同于其他几个运算符，它有以下几个特点：")]),t._v(" "),a("ul",[a("li",[t._v("运算中其中一方为字符串，那么就会把另一方也转换为字符串")]),t._v(" "),a("li",[t._v("如果一方不是字符串或者数字，那么会将它转换为数字或者字符串")])]),t._v(" "),a("p",[t._v("那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字")]),t._v(" "),a("h5",{attrs:{id:"比较运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比较运算符"}},[t._v("#")]),t._v(" 比较运算符")]),t._v(" "),a("ul",[a("li",[t._v("如果是对象，就通过 "),a("code",[t._v("toPrimitive")]),t._v(" 转换对象")]),t._v(" "),a("li",[t._v("如果是字符串，就通过 "),a("code",[t._v("unicode")]),t._v(" 字符索引来比较")])]),t._v(" "),a("h3",{attrs:{id:"包装类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包装类"}},[t._v("#")]),t._v(" 包装类")]),t._v(" "),a("p",[t._v("JS中有三个基本数据类型是比较特殊的存在，分别是 "),a("code",[t._v("String、number、Boolean")]),t._v(" ，每当我们给原始值赋属性值时 后台都会给我们偷偷转换 调用包装类")]),t._v(" "),a("p",[t._v("区别：")]),t._v(" "),a("blockquote",[a("p",[t._v("引用类型和基本包装对象的区别在于，生存期，引用类型所创建的对象，在执行期间一直在内存中，而基本包装对象只是存在一瞬间（也就是执行完后变量就变成 "),a("code",[t._v("null")]),t._v("）。")])]),t._v(" "),a("p",[t._v("所以，JS中只有对象才有属性和方法，原始值没有属性和方法。")])])}),[],!1,null,null,null);s.default=e.exports}}]);